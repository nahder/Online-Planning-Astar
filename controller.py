from a_star import A_star
import numpy as np 
import matplotlib.pyplot as plt 
from matplotlib.animation import FuncAnimation
# Design an inverse kinematic controller to drive a path generated by your online A* implementation based on
# the model you developed in step 1 of HW0. 

# The function should output translational and rotational speeds [v,w]
# that will allow the robot to achieve a target 2D position [x_t, y_t] given its current position and heading [x,y,theta].
# consider the robot's current speeds and restrict maximum velocities to v_dot=.288 m/s^2 and w_dot = 5.579 rad/s^2.
# use a sampling rate of dt = .1s.

class IK_controller: 
    def __init__(self, astar_planner, start=None, goal=None): 
        self.planner = astar_planner
        self.start = start #world coords
        self.goal = goal #world coords

        self.grid_path = self.planner.online_plan_path(self.start,self.goal) 

        self.world_path = self.convert_path_to_world(self.grid_path) #convert to world coordinates

        self.grid_start = self.planner.world_to_grid(*self.start)

        self.cur_pose = (start[0]-(self.planner.cell_size/2),start[1]-(self.planner.cell_size/2),-np.pi/2) #x y theta

        self.dt = .1
        self.max_linear_accel = 0.288
        self.max_angular_accel = 5.579

        self.prev_command = (0.0,0.0) 
        self.prev_pose = self.cur_pose 
        self.trajectory = [self.cur_pose]  

    def motion_model(self,u,prev_state,dt): 
        #add noise later
        x_prev,y_prev,theta_prev = prev_state  

        v,w = u 

        eps = 0.0
        x_new = x_prev + v*(1+eps) * np.cos(theta_prev)*dt 
        y_new = y_prev + v*(1+eps) * np.sin(theta_prev)*dt 
        theta_new = theta_prev + w*(1+eps)*dt

        if theta_new>np.pi: 
            theta_new -= 2*np.pi 
        else: 
            theta_new += 2*np.pi 

        return x_new,y_new,theta_new


    def distance(self,p1,p2): 
         return np.sqrt((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2)
    
    def convert_path_to_world(self,path): 
        return [self.planner.grid_to_world(x,y) for x,y in path]
    
    def wrap_angle(self,angle):
        return (angle + np.pi) % (2 * np.pi) - np.pi

    def control_cmd(self, target_world):
        # compute movement command to go to target
        xt, yt = target_world

        x, y, heading = self.cur_pose
        angle_to_target = self.wrap_angle(np.arctan2(yt - y, xt - x))
        rel_bearing = self.wrap_angle(angle_to_target - heading)
        
        distance_error = self.distance((xt, yt), (x, y))

        kp_dist, kp_angle = .3, 2.5

        v = kp_dist * distance_error  
        w = kp_angle * rel_bearing 

        linear_accel = np.clip((v - self.prev_command[0]) / self.dt, -self.max_linear_accel, self.max_linear_accel)
        angular_accel = np.clip((w - self.prev_command[1]) / self.dt, -self.max_angular_accel, self.max_angular_accel)

        if linear_accel > self.max_linear_accel or -linear_accel < -self.max_linear_accel:
            v = self.prev_command[0] + linear_accel * self.dt
        
        if angular_accel > self.max_angular_accel or -angular_accel < -self.max_angular_accel:
            w = self.prev_command[1] + angular_accel * self.dt

        self.prev_command = (v, w)
        return v, w

    def move_robot(self, command):
        #given a command, update the robots pose
        new_pose = self.motion_model(command, self.cur_pose, self.dt)
        self.prev_pose = self.cur_pose 
        self.cur_pose = new_pose 
        self.trajectory.append(self.cur_pose)
    
    def follow_waypoints(self):
        plt.figure(figsize=(5,10))
        plt.imshow(self.planner.grid, cmap='gray_r')

        if self.grid_path:
            path_x, path_y = zip(*self.grid_path)
            plt.plot(path_x, path_y, 'ro-', markersize=5.0)

        # highlight start and goal points
        start_idx = self.planner.world_to_grid(self.start[0], self.start[1])
        goal_idx = self.planner.world_to_grid(self.goal[0], self.goal[1])
        
        plt.plot(start_idx[0], start_idx[1], 'go', markersize=8.0)  # green color for start
        plt.plot(goal_idx[0], goal_idx[1], 'bo', markersize=8.0)    # blue color for goal
        
        for target in self.world_path: #target in world coordinates
            while self.distance(self.cur_pose[:2], target) > .2:
                cmd = self.control_cmd(target)
                self.move_robot(cmd)
                
                traj_x, traj_y, _ = zip(*self.trajectory)
                traj_x_grid, traj_y_grid = zip(*[self.real_to_grid(x, y) for x, y in zip(traj_x, traj_y)])
                plt.plot(traj_x_grid, traj_y_grid, 'b-', markersize=3.0)
                target_grid = self.planner.world_to_grid(target[0], target[1])
                plt.plot(target_grid[0], target_grid[1], 'yo', markersize=3.0)    # yellow color for current target
                plt.pause(0.02)

        plt.title("A* Pathfinding with Robot's Trajectory")
        plt.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)  # remove padding
        plt.margins(0, 0)  # No margins
        plt.show()


    def real_to_grid(self, x_real, y_real):
        x_min, y_min = -2, -6
        x_grid = (x_real - x_min) / self.planner.cell_size
        y_grid = (y_real - y_min) / self.planner.cell_size
        return x_grid, y_grid
            
    def visualize_results(self):
        print("start:", self.start, "goal:", self.goal)
        plt.figure(figsize=(5,10))
        plt.grid(color='black', linewidth=0.5)
        plt.xticks(np.arange(-0.5, self.planner.grid.shape[1], 1), [])
        plt.yticks(np.arange(-0.5, self.planner.grid.shape[0], 1), [])
        plt.imshow(self.planner.grid, cmap='gray_r')

        # plotting the A* path
        if self.grid_path:
            path_x, path_y = zip(*self.grid_path)
            plt.plot(path_x, path_y, 'ro-', markersize=5.0)

        # highlight start and goal points
        start_idx = self.planner.world_to_grid(self.start[0], self.start[1])
        goal_idx = self.planner.world_to_grid(self.goal[0], self.goal[1])

        plt.plot(start_idx[0], start_idx[1], 'go', markersize=8.0)  # green color for start
        plt.plot(goal_idx[0], goal_idx[1], 'bo', markersize=8.0)    # blue color for goal

        # plotting the robot's trajectory
        traj_x, traj_y, _ = zip(*self.trajectory)
        traj_x_grid, traj_y_grid = zip(*[self.real_to_grid(x, y) for x, y in zip(traj_x, traj_y)])
        plt.plot(traj_x_grid, traj_y_grid, 'b-', markersize=3.0)  

        plt.title("A* Pathfinding with Robot's Trajectory")
        plt.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)  #remove padding
        plt.margins(0, 0)  # No margins
        plt.gca().xaxis.set_major_locator(plt.NullLocator())
        plt.gca().yaxis.set_major_locator(plt.NullLocator())
        plt.show()



def main(): 
    a_star = A_star(1, (-2, 5), (-6, 6), 1.0)
    set1 = [
        {"start": [0.5, -1.5], "goal": [0.5, 1.5]},
        {"start": [4.5, 3.5], "goal": [4.5, -1.5]},
        {"start": [-0.5, 5.5], "goal": [1.5, -3.5]}
    ]

    start = (0.5,-1.5) 
    goal = (0.5,1.5) 
    controller = IK_controller(a_star,start,goal) #start, goal in world coordinates 
    controller.follow_waypoints()
    # controller.visualize_results() 


if __name__ == "__main__":
    main()
