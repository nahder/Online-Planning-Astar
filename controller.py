from a_star import A_star
import numpy as np 
import matplotlib.pyplot as plt 
from matplotlib.animation import FuncAnimation
# Design an inverse kinematic controller to drive a path generated by your online A* implementation based on
# the model you developed in step 1 of HW0. 

# The function should output translational and rotational speeds [v,w]
# that will allow the robot to achieve a target 2D position [x_t, y_t] given its current position and heading [x,y,theta].
# consider the robot's current speeds and restrict maximum velocities to v_dot=.288 m/s^2 and w_dot = 5.579 rad/s^2.
# use a sampling rate of dt = .1s.

class IK_controller: 
    def __init__(self, astar_planner, start=None, goal=None, show_animation=True): 
    
        self.planner = astar_planner
        self.start = start #world coords
        self.goal = goal #world coords

        self.grid_path = self.planner.online_plan_path(self.start,self.goal) 

        self.world_path = self.convert_path_to_world(self.grid_path) #convert to world coordinates

        self.grid_start = self.planner.world_to_grid(*self.start)

        self.cur_pose = (start[0]-(self.planner.cell_size/2),start[1]-(self.planner.cell_size/2),-np.pi/2) #x y theta

        self.dt = .1
        self.max_linear_accel = 0.288
        self.max_angular_accel = 5.579

        self.prev_command = (0.0,0.0) 
        self.prev_pose = self.cur_pose 
        self.trajectory = [self.cur_pose]  
        self.show_animation = show_animation

    def motion_model(self,u,prev_state,dt): 
        #add noise later
        x_prev,y_prev,theta_prev = prev_state  

        v,w = u 

        eps = 0.0
        x_new = x_prev + v*(1+eps) * np.cos(theta_prev)*dt 
        y_new = y_prev + v*(1+eps) * np.sin(theta_prev)*dt 
        theta_new = theta_prev + w*(1+eps)*dt

        if theta_new>np.pi: 
            theta_new -= 2*np.pi 
        else: 
            theta_new += 2*np.pi 

        return x_new,y_new,theta_new


    def distance(self,p1,p2): 
         return np.sqrt((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2)
    
    def convert_path_to_world(self,path): 
        return [self.planner.grid_to_world(x,y) for x,y in path]
    
    def wrap_angle(self,angle):
        return (angle + np.pi) % (2 * np.pi) - np.pi

    def control_cmd(self, target_world):
        # compute movement command to go to target
        xt, yt = target_world
        x, y, heading = self.cur_pose
        angle_to_target = self.wrap_angle(np.arctan2(yt - y, xt - x))
        rel_bearing = self.wrap_angle(angle_to_target - heading)
        
        distance_error = self.distance((xt, yt), (x, y))

        kp_dist, kp_angle = .3, 2.5

        v = kp_dist * distance_error  
        w = kp_angle * rel_bearing 

        linear_accel = np.clip((v - self.prev_command[0]) / self.dt, -self.max_linear_accel, self.max_linear_accel)
        angular_accel = np.clip((w - self.prev_command[1]) / self.dt, -self.max_angular_accel, self.max_angular_accel)

        if linear_accel > self.max_linear_accel or -linear_accel < -self.max_linear_accel:
            v = self.prev_command[0] + linear_accel * self.dt
        
        if angular_accel > self.max_angular_accel or -angular_accel < -self.max_angular_accel:
            w = self.prev_command[1] + angular_accel * self.dt

        self.prev_command = (v, w)
        return v, w

    def move_robot(self, command):
        #given a command, update the robots pose
        new_pose = self.motion_model(command, self.cur_pose, self.dt)
        self.prev_pose = self.cur_pose 
        self.cur_pose = new_pose 
        self.trajectory.append(self.cur_pose)
    
    def follow_waypoints(self):
        for target in self.world_path:  # target in world coordinates
            while self.distance(self.cur_pose[:2], target) > .2:
                cmd = self.control_cmd(target)
                self.move_robot(cmd)

    def real_to_grid(self, x_real, y_real):
        x_min, y_min = -2, -6
        x_grid = (x_real - x_min) / self.planner.cell_size
        y_grid = (y_real - y_min) / self.planner.cell_size
        return x_grid, y_grid
            

    def visualize_results(self):
        plt.figure(figsize=(5, 10))

        if self.show_animation:
            # Animate the trajectory and heading
            for i, pose in enumerate(self.trajectory):
                plt.clf()  # Clear the figure to remove the previous arrow
                plt.imshow(self.planner.grid, cmap='gray_r')  # Redraw the grid
                self.redraw_static_elements()  # Redraw the static elements like the A* path, start, and goal

                # Plot the trajectory up to the current pose in blue
                traj_up_to_current = self.trajectory[:i+1]
                traj_x, traj_y, _ = zip(*traj_up_to_current)
                traj_x_grid, traj_y_grid = zip(*[self.real_to_grid(x, y) for x, y in zip(traj_x, traj_y)])
                plt.plot(traj_x_grid, traj_y_grid, 'o', color='blue', markersize=1.0, zorder=2)

                # Draw a magenta arrow for the heading with a higher zorder
                self.draw_heading_arrow(pose, scale=0.2, color='magenta', zorder=3)
                plt.pause(0.02)

                # Set plot limits and title

                plt.title("A* Pathfinding with Robot's Trajectory")

            plt.show()  # Show the animation
        else:
            # Show the static plot with heading arrows at certain timesteps
            plt.imshow(self.planner.grid, cmap='gray_r')  # Redraw the grid

            self.redraw_static_elements()  # Redraw the static elements

            # Plot the final trajectory in blue
            traj_x, traj_y, _ = zip(*self.trajectory)
            traj_x_grid, traj_y_grid = zip(*[self.real_to_grid(x, y) for x, y in zip(traj_x, traj_y)])
            plt.plot(traj_x_grid, traj_y_grid, 'o', color='blue', markersize=1.0, zorder=2)

            # Draw magenta heading arrows at certain timesteps
            for i, pose in enumerate(self.trajectory):
                if i % 20 == 0:  # Adjust the timestep interval as needed
                    self.draw_heading_arrow(pose, scale=0.2, color='magenta', zorder=3)

            plt.title("A* Pathfinding with Robot's Trajectory")
            plt.show()  # Show the final static plot

    def redraw_static_elements(self):
        # Redraw static elements like the A* path, start, and goal points
        path_x, path_y = zip(*self.grid_path)
        plt.plot(path_x, path_y, color='grey', marker='o', linestyle='-', markersize=5.0, zorder=1)
        start_idx = self.planner.world_to_grid(*self.start)
        goal_idx = self.planner.world_to_grid(*self.goal)
        plt.plot(start_idx[0], start_idx[1], 'o', color='red', markersize=8.0, zorder=2)
        plt.plot(goal_idx[0], goal_idx[1], 'o', color='green', markersize=8.0, zorder=2)

    def draw_heading_arrow(self, pose, scale=1.0, color='magenta', zorder=3):
        x, y, theta = pose
        dx = scale * np.cos(theta)  # Calculate the change in x
        dy = scale * np.sin(theta)  # Calculate the change in y
        x_grid, y_grid = self.real_to_grid(x, y)
        plt.arrow(x_grid, y_grid, dx, dy, head_width=0.05, head_length=0.15, fc=color, ec=color, zorder=zorder)
        
    def highlight_path(self, path, value=0.8):
        # value=0.8 for light gray in a grayscale image where 1 is white and 0 is black
        for x, y in path:
            self.grid[y, x] = value  # Update the grid cell to light gray for the A* path

def main(): 
    a_star = A_star(1, (-2, 5), (-6, 6), 1.0)
    set1 = [
        {"start": [0.5, -1.5], "goal": [0.5, 1.5]},
        {"start": [4.5, 3.5], "goal": [4.5, -1.5]},
        {"start": [-0.5, 5.5], "goal": [1.5, -3.5]}
    ]

    start = (0.5,-1.5) 
    goal = (0.5,1.5) 
    controller = IK_controller(a_star,start,goal,True) #start, goal in world coordinates 
    controller.follow_waypoints()
    controller.visualize_results() 


if __name__ == "__main__":
    main()
