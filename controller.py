from a_star import A_star
from motion_model import sampling_motion_model
import numpy as np 
import matplotlib.pyplot as plt 
# Design an inverse kinematic controller to drive a path generated by your online A* implementation based on
# the model you developed in step 1 of HW0. 

# The function should output translational and rotational speeds [v,w]
# that will allow the robot to achieve a target 2D position [x_t, y_t] given its current position and heading [x,y,theta].
# consider the robot's current speeds and restrict maximum velocities to v_dot=.288 m/s^2 and w_dot = 5.579 rad/s^2.
# use a sampling rate of dt = .1s.

class IK_controller: 
    def __init__(self, astar_planner, start=None, goal=None): 
        self.planner = astar_planner
        self.start = start 
        self.goal = goal 

        self.path = self.planner.online_plan_path(self.start,self.goal) 

        self.cur_pose = (start[0],start[1],0.0) #x y theta
        self.dt = .1
        # self.max_linear_accel = 0.288
        # self.max_angular_accel = 5.579
        self.max_linear_accel = 0.288
        self.max_angular_accel = 5.579

        self.prev_command = (0.0,0.0) 
        self.prev_pose = self.cur_pose 
        self.trajectory = [self.cur_pose]  

    def distance(self,p1,p2): 
         return np.sqrt((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2)
    
    def determine_command(self, target):
        #compute movement command to go to target
        xt, yt = self.planner.index_to_position(target[0], target[1]) #convert back from a* grid path to real world distances

        x, y, heading = self.cur_pose
        angle_to_target = np.arctan2(yt - y, xt - x)
        rel_bearing = angle_to_target - heading

        kp_dist, kp_angle = .8,.52
        v = kp_dist * self.distance((xt, yt), (x, y))  # linear vel
        w = kp_angle * rel_bearing  # angular vel 

        # calculate and clip accelerations
        linear_accel = np.clip((v - self.prev_command[0]) / self.dt, -self.max_linear_accel, self.max_linear_accel)
        angular_accel = np.clip((w - self.prev_command[1]) / self.dt, -self.max_angular_accel, self.max_angular_accel)

        # calculate adjusted velocities using clipped accelerations
        v = self.prev_command[0] + linear_accel * self.dt
        w = self.prev_command[1] + angular_accel * self.dt
        
        self.prev_command = (v, w)
        return v, w

    def move_robot(self, command):
        #given a command, update the robots pose
        new_pose = sampling_motion_model(command, self.prev_pose, self.dt)
        self.prev_pose = self.cur_pose 
        self.cur_pose = new_pose 
        self.trajectory.append(self.cur_pose)

    def follow_waypoints(self):
        #go thru all the target points, move on once within distance threshold
        for target in self.path:
            while self.distance(self.cur_pose[:2], self.planner.index_to_position(target[0], target[1])) > 0.55:
                cmd = self.determine_command(target)
                self.move_robot(cmd)

    def real_to_grid(self, x_real, y_real):
        x_min, y_min = -2, -6
        x_grid = (x_real - x_min) / self.planner.cell_size
        y_grid = (y_real - y_min) / self.planner.cell_size
        return x_grid, y_grid
            
    def visualize_results(self):
        print("start:", self.start, "goal:", self.goal)
        plt.figure(figsize=(5,10))
        plt.grid(color='black', linewidth=0.5)
        plt.xticks(np.arange(-0.5, self.planner.grid.shape[1], 1), [])
        plt.yticks(np.arange(-0.5, self.planner.grid.shape[0], 1), [])
        plt.imshow(self.planner.grid, cmap='gray_r')

        # plotting the A* path
        if self.path:
            path_x, path_y = zip(*self.path)
            plt.plot(path_x, path_y, 'ro-', markersize=5.0)

        # highlight start and goal points
        start_idx = self.planner.position_to_index(self.start[0], self.start[1])
        goal_idx = self.planner.position_to_index(self.goal[0], self.goal[1])

        plt.plot(start_idx[0], start_idx[1], 'go', markersize=8.0)  # green color for start
        plt.plot(goal_idx[0], goal_idx[1], 'bo', markersize=8.0)    # blue color for goal

        # plotting the robot's trajectory
        traj_x, traj_y, _ = zip(*self.trajectory)
        traj_x_grid, traj_y_grid = zip(*[self.real_to_grid(x, y) for x, y in zip(traj_x, traj_y)])
        plt.plot(traj_x_grid, traj_y_grid, 'b-', markersize=3.0)  

        plt.title("A* Pathfinding with Robot's Trajectory")
        plt.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)  #remove padding
        plt.margins(0, 0)  # No margins
        plt.gca().xaxis.set_major_locator(plt.NullLocator())
        plt.gca().yaxis.set_major_locator(plt.NullLocator())
        plt.show()



def main(): 
    a_star = A_star(1, (-2, 5), (-6, 6), 1.0)
    set1 = [
        {"start": [0.5, -1.5], "goal": [0.5, 1.5]},
        {"start": [4.5, 3.5], "goal": [4.5, -1.5]},
        {"start": [-0.5, 5.5], "goal": [1.5, -3.5]}
    ]
    start = (0.5,-1.5) 
    goal = (0.5,1.5) 
    controller = IK_controller(a_star,start,goal) 
    controller.follow_waypoints()
    controller.visualize_results() 


if __name__ == "__main__":
    main()
